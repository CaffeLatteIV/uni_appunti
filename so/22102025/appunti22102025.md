# Semafori

```c
shared Object buffer;
Semaphore empty = new Semaphore(1);
Semaphore full = new Semaphore(0);
```

```c
process Producer {
  while (true) {
    Object val = produce();
    empty.P();
    buffer = val;
    full.V();
  }
}
process Consumer {
  while (true) {
    full.P();
    Object val = buffer;
    empty.V();
    consume(val);
  }
}
```
Arriva il consumer, esegue `full.P()`, visto che full è zero lui aspetta
Arriva il producer ed esegue `empty.P()` e decrementa empty (0), nel buffer mette il suo val (qualsiasi), e infine incrementa full (`full.V()`)
ora consumer può riprendere e salva sul buffer il val 1, incrementa il val di `empty` e consuma il val (buffer)
producer continua e genera un nuovo valore, decrementa empty,salva sul buffer il valore e incrementa full 


## Buffer limitato
simile al problema del produttore/consumatore ma lo scambio non avviene tramite un singolo elemento ma tramite un buffer di dimensione limitata (es vettore di elementi)
```C
Queue q(maxsize = SIZE);
Semaphore empty = new Semaphore(SIZE);
Semaphore full = new Semaphore(0);
Semaphore mutex = new Semaphore(1);

process Producer {
  while (true) {
    Object val = produce();
    empty.P();
    mutex.P();
    q.enqueue(val);
    mutex.V();
    full.V();
  }
}

process Consumer {
  while (true) {
    Object val;
    full.P();
    mutex.P();
    val = q.dequeue();
    mutex.V();
    empty.V();
    consume(val);
  }
}
```
Mutex si occupa di controllare che quando producer scrive nella coda, il consumer non sta leggendo (e viceversa)
se invertissi `empty.P()` e `mutex.P()` (in poducer) avrei un deadlock

Domande:
Q: è possibile utilizzare il codice del lucido precedente con
produttori e consumatori multipli?
A: Si, senza modificare il codice, perchè solo un processo può leggere o scrivere nel buffer

- Caso 1: Produttore/Consumatore
 è possibile che un valore sia sovrascritto? No
Q: è possibile che un valore sia letto più di una volta? No

- Caso 2: Buffer limitato
Q: è possibile che un valore sia sovrascritto?
Q: è possibile che un valore sia letto più di una volta?
Q: possibilità di deadlock?
Q: possibilità di starvation?


## Cena dei Filosofi - Soluzione errata
```C
Semaphore chopsticks = { new Semaphore(1), ..., new Semaphore(1) };
process Philo[i] { /* i = 0...4 */
  while (true) {
    // think
    chopstick[i].P();
    chopstick[(i+1)%5].P();
    // eat
    chopstick[i].V();
    chopstick[(i+1)%5].V();
  }
}

```
 Perché è errata?
Deadlock perchè tutti i filosofi prendono la forchetta di sinistra (i) e attendono quella di destra (i+1 %5) infinitamente
Il problema si risolve facendo "sedere" al massimo n-1 filosofi. Soluzione più ingegnosa:
- rompendo la simmetria (filosofo mancino)
```C
process Philo[4] {
  while (true) {
    think
    chopstick[0].P();
    chopstick[4].P();
    eat
    chopstick[0].V();
    chopstick[4].V();
  }
}
```
Altre soluzioni:
- i filosofi di indice pari sono mancini, gli altri destri (in caso di collisione un filosofo deve attendere che i due vicini abbiano terminato)
- al massimo n-1 filosofi possono sedersi a tavola
- le bacchette devono essere prese insieme (necessita di un altra sezione critica)

## Problema lettori e scrittori

un database è condiviso tra un certo numero di processi 
Esistono due tipi di processi
- lettori: accedono al database per leggerne il contenuto
- scrittori: accedono per aggiornare il contenuto del database

**Proprietà**:
se uno scrittore accede a un DB per aggiornarlo esso opera in mutua esclusione; nessun altro lettore o scrittore può accedere al DB
se nessuno scrittore sta accedendo al db, tutti i lettori possono accedere al DB

- Motivazioni
 la competizione per le risorse avviene a livello di classi di processi e non solo a livello di processi
Mostra che mutua esclusione e condivisione possono anche coesistere

- Invariante
sia nr il numero dei lettori che stanno accendo al database
sia nw il numero di scrittori che stanno accedendo al database
L'invariante è il seguente:
```
(nr >= 0 && nw==0) || (nr == 0 && nw == 1)
```

**Nota:** il controllo può passare dai lettori agli scrittori o viceversa quando: `nr == 0 && nw == 0`
```
```
```C
/* Variabili condivise */
int nr = 0;
Semaphore rw = new Semaphore(1);
Semaphore mutex = new Semaphore(1);
void startRead() {
  mutex.P();
  if (nr == 0)
    rw.P();
  nr++;
  mutex.V();
  }
void startWrite() {
  rw.P();
}
void endRead() {
  mutex.P();
  nr--;
  if (nr == 0)
    rw.V();
  mutex.V();
}
void endWrite() {
  rw.V();
}
```

